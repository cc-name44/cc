## js 解析型语言

#### 语言分析
作用：全局检查是否有语法错误

#### 预编译
##### 首先编译GO
1.创建GO
2.全局【var】声明的变量提升，并赋值undefined
   ----省略var的变量 作用是赋值  没有变量提升
3.函数声明提升，并赋值函数引用

解析执行全局代码，可能会望GO中新增属性，也可能对GO中属性重新赋值
GO 中属性 是【变量】或者【函数名】

##### 当函数执行时：编译函数方法体  局部作用域
1.创建AO
2.提升形参  并赋值undefined
3.提升方法体 在return之前【var】声明的变量，并赋值为undefined
4.形参与实参相统一（给形参赋值）
5.提升函数  查找 方法体中【声明】的函数 提升函数并赋值  函数应用

解析执行
函数执行完毕  AO销毁（闭包中保留）

#### 注意
1.只有存在作用域时  才会用预编译
2.es5之前  每个作用域都需要预编译
3.对于同一个作用域  一定是是先编译后执行
  不同的作用域之间  不存在编译和执行顺序
#### 解析执行
1.从第一行代码  按照顺序往下执行，每次执行一行代码 都是对变量的重新赋值
2.异步程序

###  如何区分声明变量 和使用变量
1.只要有 var 一定是声明变量  一定有预编译
2.只要省略关键字  一定是使用变量
        - 重新赋值  具体赋值是什么？ 关键看 赋值运算符
        - 直接用值  用的是哪一个值？

### 变量的使用规则
1.在自己的作用域中找var  如果没有 往上一层作用域中找 直到找到全局作用域，一直没有 报错xx is not defined
2.入果找到了，找哪一个作用域中找到了，就用哪一个作用域中的变量，火堆该作用域中变量重新赋值

用什么值？
1.按照执行顺序用距离他最近的一次赋值：简单console.log(变量)

### 作用域
1.一个作用域下可以有多个子作用域
2.相邻的子域之间不可以相互访问，父域不可以访问子域的内容
3.子域可以访问父域的变量

### 作用域链
什么是作用链